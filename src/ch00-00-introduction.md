# 소개

> Note: 이 책은 [No Starch Press][nsp]에서 ebook 형태로
> 무료 제공되는 [The Rust Programming Language][nsprust]와
> 동일한 내용을 원작자의 동의하에 번역한 것입니다.

[nsprust]: https://nostarch.com/rust-programming-language-2nd-edition
[nsp]: https://nostarch.com/

러스트 입문서, *The Rust Programming Language*에 오신 것을 환영합니다.
러스트 프로그래밍 언어는 더 빠르고 안정적인 소프트웨어를 작성하는 데 도움을
줍니다. 여태 프로그래밍 언어 디자인에 있어 저수준 (low-level) 제어와 고수준
(high-level) 문법은 양립하기 어려웠지만, 러스트는 이러한 충돌에 도전합니다.
강력한 기술적 능력과 뛰어난 개발자 경험 간의 균형을 유지함으로써, 러스트는
(메모리 사용과 같은) 저수준 제어에 전통적으로 동반되는 귀찮은 것들
없이 이를 제어할 수 있게 해 줍니다.

## 러스트는 누구에게 적합할까요?

러스트는 다양한 사람들에게 이상적입니다. 이유도 각각 다양하나,
대표적인 몇 가지 경우를 살펴보도록 하겠습니다.

### 개발팀

러스트는 시스템 프로그래밍 지식이 적은 사람부터 많은 사람까지 다양하게
구성된 대규모 개발자 팀 간의 협업을 위한 생산적인 도구로 입증되고
있습니다. 저수준 코드는 다양한 종류의 미묘한 버그가 발생하기 쉬운데,
대부분의 다른 언어에서는 숙련된 개발자에 의해 실행된 대규모 테스트와
면밀한 코드 검토를 통해서만 발견할 수 있습니다. 러스트에서는 컴파일러가
동시성 버그 등 찾기 어려운 버그가 있는 코드의 컴파일을 거부함으로써
수문장 역할을 합니다. 이는 개발팀이 디버깅보다 프로그램 로직 개발에
집중하게 만드는 효과를 가져옵니다.

러스트는 시스템 프로그래밍 세계에 현대적인 개발자 도구를 도입하기도 했습니다:

* 카고 (Cargo) 라는 기본 구성에 포함된 의존성 (dependency) 관리자 및 빌드
  도구를 통하여 러스트 생태계에서 의존성을 고통 없이 일관되게 추가하고,
  컴파일하고, 관리할 수 있습니다.
* Rustfmt 포맷팅 도구는 개발자들 사이에서 코딩 스타일을
  통일시킵니다.
* 러스트 언어 서버 (Rust Language Server) 는 코드 자동완성과
  인라인 에러 메시지를 결합해 IDE (통합 개발 환경) 의 편의성을 높입니다.

개발자들은 이 3가지를 포함한 러스트 생태계의 여러 도구를 이용하여
생산성을 희생하지 않고 저수준 코드를 작성할 수 있습니다.

### 학생

학생 및 시스템 개념을 공부하려는 분도 환영입니다.
많은 이들이 러스트로 운영체제 개발 등의 주제를 공부해 왔으며,
커뮤니티 역시 초보자를 환영하고 질문에 친절히 대답해 주는
분위기가 형성되어 있습니다. 러스트 팀은 이 책과 같은 노력을 통해
더 많은 사람, 특히 프로그래밍 입문자들이 시스템 개념에 접근하기
쉬워지길 바랍니다.

### 회사

회사의 규모를 불문하고, 수많은 회사가 이미 웹 서비스,
데브옵스 도구화 등 다양한 작업에 러스트를 사용하고 있습니다.
그 이외에도 러스트는 커맨드 라인 도구, 임베디드 장치, 오디오 및 비디오 분석,
암호화폐, 생물정보학, 검색 엔진, IOT 애플리케이션, 머신 러닝,
심지어 파이어폭스 웹 브라우저의 핵심 부분을 만드는 데에도 사용됩니다.

### 오픈 소스 개발자

러스트는 여러분의 기여가 절실합니다.
그렇기에 러스트 프로그래밍 언어 자체에 기여하실 분이나 커뮤니티 활동,
개발자 도구 제작, 라이브러리 개발 등에 참여하실 분께도 정말 적합한 언어입니다.

### 속도와 안정성을 중시하는 사람

러스트는 속도와 안정성을 중시하는 사람들을 위한 언어입니다
(이때의 속도란 프로그램을 작성하는 속도 및 만들어진 프로그램의
속도를 지칭합니다.) 개발자가 불안정한 레거시 코드를 수정하길 꺼리는
타 언어의 컴파일러 검사와는 달리 러스트 컴파일러의 검사는
기능 추가 및 리팩터링 과정에서 안정성을 보장합니다.
또한 비용 없는 추상화, 즉 컴파일러가 생성하는 저수준 코드를
개발자가 직접 작성한 만큼 빠르게 만들 수 있도록 노력하여
안정적인 코드가 빠른 코드도 될 수 있도록 합니다.

앞서 언급해 온 대상도 대표적인 이해관계자 중 일부일 뿐입니다. 러스트의 최종 목표는,
기존의 안정성**이나** 생산성 중 하나를 택하면 나머지 하나를 잃는 것이 당연시되던, 프로그래머들이
여태 받아들여 온 절충안를 제거하는 것입니다. 러스트는 안정성**과**  생산성 두 마리 토끼를 모두 잡고,
마찬가지 취급을 받던 성능**과** 개발자 친화성 (ergonomics) 까지 동시에 끌어안았습니다.
한번 러스트를 사용해 보고, 이 특성이 여러분과도 잘 맞는지 판단해 보세요.

## 이 책은 어떤 사람을 위한 책인가요?

이 책은 여러분이 이미 다른 프로그래밍 언어를 배운 적이 있다는 가정하에
집필되었지만, 어떤 언어를 배웠었는지는 상관하지 않습니다. 이 책에서는 다양한
프로그래밍 배경을 가진 사람들이 폭넓게 접근할 수 있는 자료를 만들기 위해
노력했습니다. 프로그래밍이라는 것이 무엇인지, 어떤 자세로 코드를 작성해야
하는지에 대해서는 길게 설명하지 않을 겁니다. 프로그래밍을 처음 배우시는 분이라면
프로그래밍을 구체적으로 소개하는 책을 읽는 것이 좋습니다.

## 이 책을 어떻게 읽어야 할까요?

먼저, 이 책은 앞에서부터 뒤까지 순서대로
읽는 가정하에 작성되었음을 알려드립니다.
따라서 보통 앞 장에서는 기초 내용을 배우고,
뒷장에서는 앞서 나온 내용을 기반으로 한 심화 내용을 배웁니다.

이 책에는 개념 장과 프로젝트 장의 두 가지 종류가 있습니다. 개념
장에서는 러스트에서의 어떤 개념에 대해 알아봅니다. 프로젝트 장에서는
그간 배운 내용을 적용하여 작은 프로그램을 함께 만들어 봅니다. 2장,
12장, 20장은 프로젝트 장이고 나머지는 개념 장입니다.

1장은 러스트를 설치하고 ‘Hello, world!’ 프로그램을 작성하는 방법,
그리고 러스트의 패키지 매니저 및 빌드 도구인 카고의 사용법을 다룹니다.
2장은 숫자 추리 게임을 직접 작성하면서 러스트로 프로그래밍하는 법을 배웁니다.
이후에 깊이 있게 배울 여러 개념을 추상적으로 다뤄볼 수 있습니다.
자기 손으로 직접 실습해 보는 걸 선호하시는 분에게 제격입니다.
3장은 다른 프로그래밍 언어와 유사한 러스트 특성을 다루는 내용이며,
4장은 소유권 시스템을 다루는 내용입니다.
이 부분은 여러 방법으로 읽을 수 있습니다.
3장을 건너뛰고 바로 4장 소유권 시스템부터 배우거나,
하나씩 차근차근 배우는 걸 선호하면 2장을 건너뛰고 3장부터 본 후,
2장으로 돌아와 배운 내용을 프로젝트에 적용해 볼 수도 있지요.

5장은 구조체 및 메서드를 다루며,
6장은 열거형과 `match` 표현식, `if let` 제어 흐름문을 다룹니다.
구조체와 열거형은 앞으로 커스텀 타입을 만드는 데 사용할 겁니다.

7장은 공개 API (Application Programming Interface) 를 만들 때,
작성한 코드와 해당 API를 체계화하기 위한 모듈 시스템 및 접근 권한 규칙을 다루며,
8장은 벡터, 문자열, 해시맵 등 표준 라이브러리가
제공하는 일반적인 컬렉션 자료구조를 다룹니다.
9장에서는 러스트의 에러 처리 철학 및 기법을 알아보겠습니다.

10장은 여러 가지 타입에 적용될 수 있는 코드를 정의하도록 해주는
제네릭 (generic), 트레잇 (trait), 라이프타임 (lifetime) 을 다루며
11장에서는 작성한 프로그램 로직이 잘 작동함을
확인하는 데 필요한 테스트 관련 내용을 다룹니다.
12장에서는 이때까지 배운 수많은 개념을 이용해
커맨드 라인 도구 `grep`의 기능 일부를
직접 구현해 볼 겁니다.

13장은 클로저 및 반복자를 다룹니다: 함수형 프로그래밍 언어에서 유래된
러스트의 기능입니다. 14장은 카고에 대한 심화 내용 및 여러분이 만든
라이브러리를 남들이 쓸 수 있도록 배포하는 방법을 다룹니다.
15장은 표준 라이브러리가 제공하는 스마트 포인터와
스마트 포인터를 구현하는 트레잇을 다룹니다.

16장에서는 여러 동시성 프로그래밍 모델에 대해 돌아보고, 러스트에서는
어째서 두려움 없이 멀티스레드 프로그래밍을 할 수 있는지 이야기하겠습니다.
17장에서는 여러분에게 익숙할 객체 지향 프로그래밍 원칙과
러스트의 표현 양식 간에 차이를 살펴보겠습니다.

18장은 러스트 프로그램 전반에 걸쳐 아이디어를 표현하는 데 강력한
방법인 패턴, 그리고 패턴 매칭을 참고 자료 형식으로 다룹니다.
19장은 안전하지 않은 러스트, 매크로, 라이프타임, 트레잇, 타입, 함수,
클로저 등 다양한 고급 주제를 다룹니다.

20장에서는 저수준 멀티스레드 웹 서버를 직접 구현하는 것으로
프로젝트 실습을 마칠 예정입니다.

마지막으로, 부록에는 러스트 관련 유용한 정보를 참고 자료
형식으로 담아두었습니다. 부록 A에는 러스트에서 사용하는 키워드들을,
부록 B에는 연산자 및 기호를, 부록 C에는 표준 라이브러리가
제공하는 derivable 트레잇을, 부록 D에는 여러 유용한 개발 도구에 대한 내용을,
부록 E에는 러스트 에디션을 각각 설명합니다. 부록 F에서는
이 책의 번역본에 대해서, 부록 G에서는 러스트와 nightly 러스트가
어떻게 만들어지는지 다룹니다.

이 책은 어떻게 읽든 상관없습니다. 일단 넘기고 싶은 부분은 넘긴 뒤,
뒷부분을 읽다가 내용이 헷갈릴 때 다시 앞으로 돌아와 읽으셔도 됩니다.
다만, 자신에게 가장 도움이 되는 방식대로 읽으시길 권합니다.

<span id="ferris"></span>

러스트를 배우는 과정에서 중요한 부분은 컴파일러가 보여주는 에러 메시지를 읽는 법을
배우는 것입니다: 에러 메시지만 잘 읽어도 코드 속 에러를 고칠 수 있기 때문이지요.
따라서, 여러분이 에러 메시지를 읽는 실력을 자연스럽게 늘릴 수 있도록 컴파일되지
않는 예제 코드와 해당 예제에서 발생하는 에러 메시지를 다양하게 보여드릴 겁니다.
그러니 눈에 보이는 아무 예제나 컴파일을 돌렸더니 에러가 나타나더라도,
일부러 에러가 나타나게 만든 예제일 수 있으니 당황하지 마시고 해당 예제 주위의 글을 읽어보세요.
편의를 위해, 오작동하도록 만든 코드에는 페리스 (Ferris) 가 등장하니 구분하는 데 참고하셔도 좋습니다.

| 페리스                                                                                                           | 의미                                          |
|------------------------------------------------------------------------------------------------------------------|---------------------------|
| <img src="img/ferris/does_not_compile.svg" class="ferris-explain" alt="Ferris with a question mark"/>            | 컴파일되지 않는 코드        |
| <img src="img/ferris/panics.svg" class="ferris-explain" alt="Ferris throwing up their hands"/>                   | 패닉이 발생하는 코드        |
| <img src="img/ferris/not_desired_behavior.svg" class="ferris-explain" alt="Ferris with one claw up, shrugging"/> | 의도대로 작동하지 않는 코드 |

덧붙이자면, 컴파일되지 않는 코드가 등장하는 내용 중 대부분은
해당 코드가 정상 작동하도록 수정해 나가는 내용입니다.

## 소스 코드

이 책을 만드는 데 사용한 원본 파일은
[GitHub (한국어 번역본)][translated_book]에서 찾아보실 수 있습니다.

[translated_book]: https://github.com/rust-kr/doc.rust-kr.org/tree/master/src
